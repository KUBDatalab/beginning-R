---
title: "A couple of plots. And making our own functions"
teaching: 80
exercises: 35
questions:
  - "How do I create scatterplots, boxplots, and barplots?"
  - "How can I define my own functions?"
  
objectives:
   - "Produce scatter plots and boxplots using Base R."
   - "Write your own function"
   - "Write loops to repeat calculations"
   - "Use logical tests in loops"
   
keypoints:
   - "Boxplots are useful for visualizing the distribution of a continuous variable."
   - "Barplots are useful for visualizing categorical data."
   - "Functions allows you to repeat the same set of operations again and again."
   - "Loops allows you to apply the same function to lots of data."
   - "Logical tests allow you to apply different calculations on different sets of data."
   
source: Rmd
---

```{r, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("04-")
source("../bin/download_data.R")
```

We start by loading the required package. **`ggplot2`** is also included in the
**`tidyverse`** package.

```{r load-package, message=FALSE, purl=FALSE}
library(tidyverse)
```

If not still in the workspace, load the data we saved in the previous lesson.


```{r load-data, purl=FALSE}
interviews_plotting <- read_csv("data_output/interviews_plotting.csv")
```

If you were unable to complete the previous lesson or did not save the data,
then you can create it now.

```{r, purl = FALSE, eval = FALSE}
## Not run, but can be used to load in data from previous lesson!
interviews_plotting <- interviews %>%
  ## pivot wider by items_owned
  separate_rows(items_owned, sep = ";") %>%
  ## if there were no items listed, changing NA to no_listed_items
  replace_na(list(items_owned = "no_listed_items")) %>%
  mutate(items_owned_logical = TRUE) %>%
  pivot_wider(names_from = items_owned, 
              values_from = items_owned_logical, 
              values_fill = list(items_owned_logical = FALSE)) %>%
  ## pivot wider by months_lack_food
  separate_rows(months_lack_food, sep = ";") %>%
  mutate(months_lack_food_logical = TRUE) %>%
  pivot_wider(names_from = months_lack_food, 
              values_from = months_lack_food_logical, 
              values_fill = list(months_lack_food_logical = FALSE)) %>%
  ## add some summary columns
  mutate(number_months_lack_food = rowSums(select(., Jan:May))) %>%
  mutate(number_items = rowSums(select(., bicycle:car)))
```

## Scatterplots ## 

Scatterplots visualizes the relation between two variables in the dataset, by
plotting individual observations in a two-dimensional graph, with the position 
in the x,y-plane defined by the values of the two variables.

The default plot function in Base R takes two vectors, one containing the values 
of the x-axis and one containing the values for the y-axis. Here we use the 
$-notation:

```{r first-scatterplot}
plot(interviews_plotting$no_membrs, interviews_plotting$number_items)
```

## Boxplots ##

## Barplots ""


## Boxplot

We can use boxplots to visualize the distribution of rooms for each
wall type:

```{r boxplot, purl=FALSE}
interviews_plotting %>%
    ggplot(aes(x = respondent_wall_type, y = rooms)) +
    geom_boxplot()
```


We can see that muddaub houses and sunbrick houses tend to be smaller than
burntbrick houses.

Notice how the  boxplot layer is behind the jitter layer? What do you need to
change in the code to put the boxplot in behind the points such that it's not 
hidden?


## Barplots

Barplots are also useful for visualizing categorical data. By default,
`geom_bar` accepts a variable for x, and plots the number of instances each
value of x (in this case, wall type) appears in the dataset.

```{r barplot-1}
interviews_plotting %>%
    ggplot(aes(x = respondent_wall_type)) +
    geom_bar()
```


To calculate this percentage data frame, we needed to use the `across()` 
function within a `summarize()` operation. Unlike the previous example with a 
single wall type variable, where each response was exactly one of the types 
specified, people can (and do) own more than one item. So there are multiple 
columns of data (one for each item), and the percentage calculation needs to be 
repeated for each column.

Combining `summarize()` with `across()` allows us to specify first, the columns 
to be summarized (`bicycle:no_listed_items`) and then the calculation. Because 
our calculation is a bit more complex than is available in a built-in function, 
we define a new formula:
* `~` indicates that we are defining a formula, 
* `sum(.x)` gives the number of people owning that item by counting the number of `TRUE` 
values (`.x` is shorthand for the column being operated on), 
* and `n()` gives the current group size.

After the `summarize()` operation, we have a table of percentages with each item 
in its own column, so a `pivot_longer()` is required to transform the table into 
an easier format for plotting. Using this data frame, we can now create a 
multi-paneled bar plot.

```{r percent-items-barplot}
percent_items %>%
    ggplot(aes(x = village, y = percent)) +
    geom_bar(stat = "identity", position = "dodge") +
    facet_wrap(~ items) +
    theme_bw() +
    theme(panel.grid = element_blank())
```

## Writing our own functions ##

When calculating an average of several values, we do two things. First we
count how many values there are. Then we sum all the values, and divides the sum
by the number of values. 
Rather than writing R-code for each of these three operations, we use the 
mean() function, where other more experienced programmers have written the code.

We can write our own functions, where we collect several operations into one 
function. 

Functions in R are defined in this way:
```{r, eval = FALSE}
function_name <- function(x){
  temporary_result_1 <- some_function(x)
  temporary_result_2 <- some_other_function(temporary_result_1)
  yet_another_function(temporary_result_2)
}
```

function_name defines the name of our function.

function(x) tells R that we are defining a function, that takes X as input.
We can then use that x as input to calculations or other functions within our
own function.

Between the curly braces {}, we define what we want our function to do.
We assign the result of some_function(x) to a temporary result, use that as
the input to a second function, and the result of that as the input to a third 
function. The result of the last calculation we do, will be returned as the 
output of our function.

> ## Exercise
>
> Write a function that calculates the average value of a numeric vector, 
> takes the square root of that average, and returns the result
>
> > ## Solution
> > One way to do this would be:
> > 
> > root_mean <- function(x){
> >              sqrt(mean(x, na.rm=T))
> >               }
> > 
> > Another way could be:
> > 
> > root_mean <- function(x){
> >              temp <- mean(x, na.rm =T)
> >              result <- sqrt(temp)
> >              result
> > }
> > 
> > 
> > 
> {: .solution}
{: .challenge}

## Logical tests in functions ##


{% include links.md %}
